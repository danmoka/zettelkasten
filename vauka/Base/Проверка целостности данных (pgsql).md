22092022 1049
Tags: #z #dev

---
# Проверка целостности на уровне приложения

В рамках транзакции Read committed возможна ситуация, при которой один оператор видит одни данные, а другой уже измененные. В рамках транзакции Read Repeatable возможна ситуация возникновения цикла, которая не разрешается без дополнительных мер. В Serializable транзакциях циклическая ситуация разрешается путем прерывания и отката одной из транзакций.

Всего этого может быть недостаточно и целостность будет разрешаться на уровне приложения. Если все транзакции сериализуемые, то обеспечивается должный уровень изоляций для операций чтения и записи.

Операторы *SELECT FOR UPDATE/SHARE* **временно** блокируют другие транзакции, которые хотят изменить/удалить выбранную строку. После фиксации или отката транзакции блокировка снимается, а параллельная транзакция выполняет конфликтующую операцию, если только действительно не было выполнено изменение, пока транзакция владела блокировкой.

Если требуется посмотреть и сравнить данные в двух таблицах, то лучше сделать строгую блокировку *SHARE* на обе таблицы(гарантирует, что в таблице нет незафиксированных изменений). Repeatable не подойдет, т.к. мы можем не увидеть данные, которые внесли. Committed не подойдет, можем получить данные в следующих командах, которые изменились в другой транзакции.

Есть записи в таблицу в параллельных транзакциях:
- committed - будешь видеть вносимые изменения при фиксации
- repeatable + блокировка на запись - гарантия, что видишь актуальные данные + новые записывать нельзя 

---
### Zero-Links
- 

---
### Links
- [[Проверка целостности данных (pgsql)]]