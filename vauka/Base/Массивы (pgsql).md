20092022 1316
Tags: #z #dev

---
# Массивы

Тип колонки таблицы можно определить как массив. Какой бы ни была размерность массива или количество элементов - всё это один тип. Указание размерности имеет смысл только для документирования, PostgreSQL этого не учитывает.

## Пример создания

```sql
CREATE TABLE product (
    price integer,
    category text[]
);
```

## Ввод значений

Запись констант: '{ знач1 разд1 знач2 разд2 знач3 ... }', где знач - это элемент массива (может также быть массивом), разд - разделить, обычно запятая.

Есть у массива несколько размерностей, то вложенные элементы должны быть одного размера, иначе будет ошибка.

```sql
'{{1, 2, 3}, {5, 6, 7}, {8, 9, 10}}'
```

## Возвращение значений

Выход за пределы массива при обращении к элементу возвращает NULL (ошибки нет). Выход среза за пределы массива возвращает пустой массив. Если срез пересекает массив, то возвращается эта область пересечения. 

Если при обращении используются срезы, то они используются и далее на всех уровнях вложенности.

Индексация начинается с 1.

```sql
-- обращение к элементу
SELECT product.category[2]
-- срез
SELECT product.category[1:2]
SELECT product.category[1:2][2]
SELECT product.category[1:]
SELECT product.category[:2]
SELECT product.category[:]
```

## Изменение массивов

Массивы можно менять целиком, по элементу, по срезу. Массивы можно конкатенировать при помощи оператора ||.

```sql
UPDATE SET category = '{1, 2, 3}';
UPDATE SET category[2] = 5;
UPDATE SET category[1:2] = '{7, 7}'
```

## Поиск

Поиск элементов осуществляется при помощи функций array_position, array_positions, операторов *ANY, ALL, &&*.

```sql
SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
```

---
### Zero-Links
- [[00 PostgreSQL]]

---
### Links
- 